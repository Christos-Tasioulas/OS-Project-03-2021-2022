Ραφαήλ-Χρήστος Τασιούλας
sdi1800191

Λειτουργικά Συστήματα Εργασία 3

Makefile

	Το Makefile περιλαμβάνει εντολές να μεταγλωττιστεί και να εκτελεστεί το πρόγραμμα καθώς και τα ορίσματα για την εκτέλεσή του. Συγκεκριμένα περιέχει την make για μεταγλώττιση, την make run για εκτέλεση, την make valgrind για εκτέλεση με valgrind και την make clean για την αφαίρεση των .ο και εκτελέσιμων αρχείου. Χρησιμοποιούνται τα arguments 20 για τον αριθμό των διαδικασιών, 0,75 για την πιθανότητα εκτέλεσης down() (k) και 3 για τον αριθμό των σημαφόρων ενδεικτικά.  


Αρχεία Δομών

	Υπάρχουν τα αρχεία δομών Heap.cpp/.h στα οποία υλοποιείται ένα minheap που χρησιμοποιείται στο πρόγραμμα. Κληρονομεί CompleteBinaryTree και χρησιμοποιεί τα αντίστοιχα .cpp/.h αρχεία που υπάρχουν. Αυτό κληρονομεί με τη σειρά του από τα BinaryTree όπου και χρησιμοποιεί τα αντίστοιχα .cpp/.h αρχεία και περιλαμβάνει και Queue, άρα έχουμε και τα Queue.cpp/.h αρχεία στον κώδικα. Τέλος, η Queue κληρονομεί από το List άρα υπάρχουν και το List.cpp\.h αρχεία. Λίστα χρησιμοποιείται στο πρόγραμμα. 
	 

Αρχεία Κώδικα

	Η εκτέλεση του κωδικά ξεκινά από την main στο main.cpp και τρέχει ως ./simulator <numProcesses> <k> <numSemaphores> με την make run. 
	Επείτα, πηγαίνει στη handle στο Handle.cpp, η οποία υπολογίζει χρόνους για όλες τις διαδικασίες χρησιμοποιώντας εκθετικές κατανομές για κάθε είδος χρόνου. Κάθε έιδος χρόνου έχει διαφορετικό λ ανάλογα πόσο μικρούς χρόνους θέλουμε. Για κάθε διαδικασία διατηρούμε τη σχέση: (χρόνος ζωής > χρόνος κρίσιμης περιοχής > χρόνος άφιξης) χρησιμοποιώντας μεγαλύτερο λ προοδευτικά. Υπολογίζονται με ομοιόμορφη κατανομή οι προτεραιότητες κάθε διαδικασίας, καθώς και οι μέσοι όροι κάθε τύπου χρόνου. Έχουν υλοποιηθεί σε αυτό το αρχείο οι συναρτήσεις για αυτές τις διαδικασίες (ed, ud, average). Δημιουργείται ο αρχικός σωρός με όλες τις διαδικασίες ταξινομημένες ανά χρόνο άφιξης και έτσι θα ξεκινήσει ο προσομοιωτής με όλα τα δεδομένα που αναφέρθηκαν.
	Στο Simulation.h ορίζεται το αντιστοιχό αντικείμενο με τα πεδία του όπως ζητήθηκαν και το σωρό με τις διαδικασίες, τον constructor, τον destructor και την συνάρτηση εκτέλεσης run.   
	Στο Simulation.cpp δημιουργείται ο προσομοιωτής, εκτελείται ο προσομοιωτής και υλοποιούνται συναρτήσεις που βοηθούν στην εκτέλεση του. Ο προσομοιωτής δημιουργεί σημαφόρους όπως υλποποιούνται στα Semaphore.cpp/.h. Ο προσομοιωτής μετρά πόσες διαδικασίες έχουν κάθε προτεραιότητα, μετρά τους χρόνους αναμονής άνα προτεραιότητα, μετρά τους χρόνους μπλοκαρίσματος διαδικασιών από διαδικασίες με μεγαλύερη προτεραιότητα και τους χρόνους που σε κάθε σημαφόρο εκτελείται η τελευταία πετυχημένη down. Δημιουργείται μια λίστα που θα αποθηκεύει όλες τις διαδικασίες μέχρι την τελική διαγραφή τους και ένας σωρός που θα ταξινομεί τις διαδικασίες αν δεν είναι μπλοκαρισμένες και αν έχουν φτάσει ανάλογα με την προτεραιότητά τους με την συνάρτηση compare_priorities_and_arrival_times. Ο προσομοιωτής τρέχει μέχρι να αδειάσει ο τελυταίος σωρός. Σε κάθε επανάληψη προχωράμε κάτα μία χρονοθυρίδα η οποία ισούται με 0.1 δευτερόλεπτα. Πρώτα εξετάζεται αν η πρώτη διαδικασία του σωρού έχει φτάσει. Αν όχι, ο σωρός αναδιοργανώνεται και προχωράμε. Αν ναι, την αφαιρούμε από το σωρό. Αν δεν έχει μπλοκαριστεί, αν δεν θα πεθάνει σε αυτή τη χρονοθυρίδα και αν δεν είναι ήδη σε κρισιμή περιοχή αποφασίζεται στην τύχη από την PerformDown αν θα εκτελέσει down() με βάση την πιθανότητα k σε αυτή τη χρονοθυρίδα. Αν η συνάρτηση, επιστρέψει true επιλέγεται τυχαία σημαφόρος από τον πίνακα με τους σημαφόρους του προσομοιωτή από την chooseSemaphore και σε όποιον σημαφόρο επιστραφεί εκτελείται η down(). Αν η down πετύχει, ο χρόνος που πέτυχε καταγράφεται στην αντίστοιχη θέση του πίνακα με το id του σημαφόρου, διαφορετικά η διαδικασία μπλοκάρεται και αναδιοργανώνεται ο σωρός. Έπειτα, για κάθε σημαφόρο, ελέγχεται αν μπορεί να εκτελεστεί up ανάλογα αν έχει περάσει ο χρόνος κρίσιμης περιοχής της διαδικασίας που μπλοκάρει τις άλλες στο σημαφόρο ή αν αυτή η διαδικασία θα πεθάνει σε αυτή τη χρονοθυρίδα για να αποφύγουμε κατάσταση deadlock. Κάθε έλεγχος για up γίνεται στην check_for_ups. Για κάθε up, αναδιοργανώνεται ο σωρός. Έπειτα, ενημερώνονται οι χρόνοι αναμονής και οι χρόνοι μπλοκαρίσματος στις αντίστοιχες συναρτήσεις (update_waiting_times, update_blocking_times). Οι συναρτήσεις διασχίζουν τον συνολικό σωρό και τον σωρό κάθε σημαφόρου αντίστοιχα(βλ. παρακάτω) με pre_order και προσθέτουν για κάθε διαδικασία μία χρονοθυρίδα στον αντίστοιχο πίνακα στην αντίστιχη θέση ανάλογα με την προτεραίοτητα κάθε διαδικασίας. Kάθε διαδικασία που θα πεθάνει στη χρονοθυρίδα που βρισκόμαστε δεν ξαναμπαίνει στο σωρό, αναδιοργανώνεται ο σωρός και προχωράμε καθώς καταγράφεται και ότι ολοκληρώθηκε. Διαφορετικά, και αν δεν είναι μπλοκαρισμένη της αφαιρέιται τόσος χρόνος ζωής όσο αξίζει μια χρονοθυρίδα q (0.1s). Στο τέλος κάθε επανάληψης, η διαδικασία που βγήκε ξαναμπαίνει στο σωρό. αυξάνεται ο χρόνος και αναδιοργανώνεται ο σωρός. Μετά το τέλος της επανάληψης, ολοκληρώνονται οι διαδικασίες, υπολογίζεται ο μέσος όρος αναμονής για κάθε διαδικασία ανά προτεραιότητα, διαιρείται ο συνολικός χρόνος αναμονής κάθε προτεραιότητας με τον αριθμό διαδικασιών κάθε προτεραιότητας και υπολογίζεται ο μέσος χρόνος μπλοκαρίσματος για κάθε διαδικασία από διαδικασία με μικρότερη προτεραιότητα ανά προτεραιότητα με αντίστοιχο τρόπο. Τέλος η empty_list διαγράφει όλες τις διαδικασίες από τη λίστα.
Στο αρχείο υπάρχει η global μεταβλητή current_time_slot που ξεκινάει από 0.0 και αυξάνεται κατά q κάθε επανάληψη του πεοσομοιωτή. 
	Στο Semaphore.h/.cpp υλοποιείατι η κλάση των σημαφόρων που έχουν id για να ξεχωρίζουν, value, το οποίο ξεκινάει από 1 για να μην μπλοκάρουν στην αρχή, μία διαδικασία η οποία είναι αυτή που βρίσκεται στην κρίσιμη περιοχή (CurrentProcess), και ένα σωρό με τις μπλοκαρισμένες διαδικασίες από τον σημαφόρο που ταξινομούνται ανάλογα την προτεραιότητά τους με τη βοηθεία της compare_priorities. Περιέχει ένα constructor, ένα destructor, τους αντίστοιχους getters και τις down και up οι οποίες είναι υλοποιημένες με βάση τα μοντέλα του μάθηματος και με παραπάνω δυνατότητες. Στην down, η οποία δέχεται ως όρισμα την διαδικασία και τον πίνακα με τους χρόνους μπλοκαρίσματος, μειώνεται το value κατά 1. Άμα ισούται με 0 η διαδικασία μπαίνει στην κρίσιμη περιοχή και γίνεται η CurrentProcess. Διαφορετικά, η διαδικασία μπαίνει στο σωρό, μπλοκάρεται και εξετάζεται η περίπτωση priority_inversion. Αυτό γίνεται στην ομώνυμη συνάρτηση που δέχεται ως όρισματα την διαδικασία που μπλοκάρει, την διαδικασία που μόλις μπλοκαρίστηκε και τον πίνακα με τους χρόνους μπλοκαρίσματος. Εξετάζεται αν η προτεραιότητα της διαδικασίας που μπλοκάρει είναι μικρότερη από αυτήν της διαδικασίας που μπλοκάρεται. Αν ισχύει αυτό, ανεβαίνει ο χρόνος μπλοκαρίσματος στην αντίστοιχη θέση προτεραιότητας κατά μία χρονοθυρίδα και οι διαδικασίες ανταλλάσσουν προτεραιότητες (priority_inheritance). Στην up, το value, αυξάνεται κατά 1 και η CurrentProcess αν υπάρχει φεύγει από την κρίσιμη περιοχή. Αν η αξία του σημαφόρου είναι μικρότερη από 1, η πρώτη διαδικασία στο σωρού ξεμπλοκάρεται, φεύγει από τον σωρό και μπαίνει αυτή στην κρισιμή περιοχή και γίνεται το CurrentProcess. Διαφορετικά, το CurrentProcess γίνεται NULL. 
	Στο Process.h/.cpp υλοποιείται η κλάση των διαδικασιών. Έχουν id για να ξεχωρίζουν, έχουν την προτεραιότητα τους, η κάθε μία τους δικούς της χρόνους άφιξης, ζωής, εναπομείνουσας ζωής και κρισιμής περιοχής. Κάθε διαδικασία περιλαμβάνει την πιθανότητα εκτέλεσης down σε χρονοθυρίδα (k). Τέλος, υπάροχυν τα πεδία is_blocked και in_critical_region που υπάρχουν για να γνωρίζουμε αν η διαδικασία έχει μπλοκαριστεί και αν έχει μπει σε κρίσιμη περιοχή αντίστοιχα. Υλοποιούνται constructor, destructor, setters και getters για όλα τα πεδία εκτός του k.


Παρατηρήσεις       

	Λόγω του priority inversion, οι μέσοι χρόνοι και οι συνολικοί χρόνοι μπλοκαρίσματος από διαδικασίες με μικρότερη προτεραιότητα είναι πολύ μικροί. Επίσης, το πρόγραμμα γίνεται αργό για πολλες διαδικασίες ως arguments ειδικά με τόσο μικρά λ στις κατανομές και αρκετά μεγάλη χρονοθυρίδα q=0.1s. Επίσης αποφεύγονται πάντα τα deadlocks. Οι τιμές των χρόνων και των προτεραιοτήτων δεν διαφέρουν άνα τρέξιμο προγράμματος με τα ίδια arguments.  
	      
        